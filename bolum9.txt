9 KABUK HAKKINDA DAHA FAZLA BÝLGÝ

ÝÇÝNDEKÝLER:

9.1 Basit Komutlar: sleep,echo ve date                  120
9.2 Kabuk Deðiþkenleri ve Ortamý                        121
9.3 Komut Tipleri - Yeniden Yüklemeler                  123
9.4 Uygun Bir Araç Olan Kabuk                           124
9.5 Dosydan Komutlar                                    127
9.6 Programlama Dili Olarak Kabuk                       128

HEDEFLER:

	*Kabuk ve ortam deðiþkenleri hakkýnda bilgi edinmek

ÖNCEDEN BÝLÝNMESÝ GEREKENLER:

	*Temel kabuk bilgisi (Bölüm 4)
	*Dosya yönetimi ve basit komutlar (Bölüm 6,Bölüm 8)
	*Metin editörü kullanýmý (Bölüm 3)

9.1 Basit Komutlar: sleep,echo ve date
 
Deneyim kazanmak için bazý araçlarý temel komutlarla açýklayacaðýz:

Sleep: Bu komut argüman olarak belirlenen saniye süresince hiçbir þey yapmaz. Eðer kullandýðýnýz kabuk biraz ara versin istiyorsanýz bu komudu kullanabilirsiniz.

 	$ sleep 10
        	      Yaklaþýk 10 saniye hiçbir þey olmaz
 	$ _

Çýkýþ argümanlarý:  echo: Bu komut argümanlarýn çýktýlarýný verir, argümanlar boþluklarla ayrýlmýþ olmalýdýr. Kabuk deðiþkenlerin referanslarýný deðiþtirebildiðinden 
beri ilginç ve kullanýþlýdýr. (bkz. Bölüm 9.2). Bu konuya benzer bir örnek:
 
$ p=Planet
$ echo Hello $p
Hello Planet
$ echo Hello ${p}oid
Hello Planetoid

(Doðrudan bir deðiþkenin deðerine bir þey eklenmek istenirse ne yapýlacaðý ikinci örnekle açýklanmýþtýr.)
	
	*Eðer echo komutu –n seçeneði ile çaðýrýlýrsa o satýr sonlandýrýcýdýr, sonraki çýktýyý yazmaz.
$ echo -n Hello
Hello_

Tarih ve saat:date: Date komutu o anki tarih ve saati gösterir. “date –help” komutu çaðýrarak çýktýnýn biçimini önemli ölçüde belirleyebilir veya “man date” komutunu 
kullanarak çevrimiçi belgeler okuyabilirsiniz.
	*(Ýkinci kez bu kýlavuzu okurken:) Özellikle önemli þehir veya zaman dilimi ismini TZ çevre deðiþkeniyle ayarlarsanýz tarih dünya saati olarak hizmet 
 	vermektedir(Genellikle baþkent).

$ date
Thu Oct 5 14:26:07 CEST 2006
$ export TZ=Asia/Tokyo
$ date
Tue Oct 5 21:26:19 JST 2006
$ unset TZ

/usr/share/zoneinfo çevresinde köklenen bilgiyle geçerli þehir isimleri ve zaman dilimlerini öðrenebilirsiniz.
 
Sistem saatini ayarlama:Her kullanýcý sistem saatini okumak için izinliyken, sadece sistem yöneticisi olan root date komutunu kullanarak sistem saatini deðiþtirebilir
ve MM, DD, hh, mm biçimindeki argümanlardan MM takvim ayý, DD takvim günü, hh saat ve mm de dakikadýr. Ýsteðe baðlý olarak nadiren iki basamaklý yýl (yüzyýl için 
muhtemelen bir ya da iki ) ve saniye (nokta ile ayrýlmýþ) gerektiðinde ekleyebilirsiniz.
 
$ date
Thu Oct 5 14:28:13 CEST 2006
$ date 08181715
date: cannot set date: Operation not permitted
Fri Aug 18 17:15:00 CEST 2006
 
 	*Date komutu yalnýzca Linux sisteminin saatini deðiþtirir. Bu saat bilgisayarýn anakartý üzerinde CMOS saatine aktarýlmamýþ olabilir. Bu nedenle bu iþlemi
	 gerçekleþtirmek için özel bir komut gerekli olabilir. Birçok daðýtým sistem kapatýldýðýnda bunu otomatik olarak yapar.

ALIÞTIRMALAR:

9.1 [!3] Varsayalým ki þu an 22 Ekim 2003, saat 12:34 ve 56. saniye olsun. Aþaðýdaki çýktýyý elde etmek için durum biçimlendirme komutlarý ve date dökümanlarýný
çalýþýr:

	1. 22-10-2003
	2. 03-294 (WK43)  (Ýki haneli yýl, yýl içinde gün sayýsý, takvim haftasý)
	3. 12h34m56s

9.2 [!2] Þu anda Los Angeles’da saat kaç?
 
9.2 Kabuk Deðiþkenleri ve Ortam

Çoðu yaygýn kabuklar gibi bash diðer programlama dillerinde bulunan özelliklere sahiptir. Örneðin;deðiþkenlerde sayýlarý veya matinlerin bir parçasýný depolamak
mümkündür ve geri alýnabilir. Deðiþkenler kabuk iþlemlerini çeþitli þekilde denetlerler.

Ayarlama deðiþkenleri:Kabuk içinde bir deðiþken “foo=bar” gibi bir komut ile ayarlanýr(Bu komut foo deðiþkenini metin deðeri bar deðiþkenine ayarlar). Önünde veya
eþittir iþareti arkasýnda boþluk eklememeye dikkat edin! Önünde dolar iþareti ile deðiþken adýný kullanarak deðiþkenin deðerini alabilirsiniz:
 
$ foo=bar
$ echo foo
foo
$ echo $foo
bar
 
(farka dikkat)

Ortam deðiþkenleri,Kabuk deðiþkenleri:Kabuk deðiþkeninden ortam deðiþkenini ayýrt edebilirsiniz. Kabuk deðiþkenleri tanýmlandýðý kabukta görülür. Harici bir komut
baþlatýlýr ve oradan kullanýlabilirken diðer taraftan ortam deðiþkenlerine çocuk süreçler aktarýlýr (Çocuk süreçler bir kabuk olmak zorunda deðildir. Her Linux 
süreçleri ortam deðiþkenlerine sahiptir). Tüm kabuðun ortam deðiikenleri ayný zamanda kabuk deðiþkenidir; fakat aksi geçerli deðildir.
	Export komutunu kullanarak varolan kabuk deðiþkenini bir ortam deðiþkeniyle ifade edebilirsiniz.

$ foo=bar              foo þu anda kabuk deðiþkeni
$ export foo           foo þu anda ortam deðiþkeni

Veya ayný zamanda kabuk ve ortam deðiþkeni gibi yeni bir deðiþken tanýmlayabilirsiniz.
 
DEÐÝÞKEN             ANLAMI
 
PWD		  Geçerli dizinin ismi
EDITOR		  Kullanýcýnýn tercih ettiði editörün ismi
PSI		  Kabuk komutu yönetme þablonu
UID		  Geçerli kullanýcýnýn kullanýcý ismi
HOME		  Geçerli kullanýcýnýn ev dizini
PATH		  Dýþ komutlar gibi uygun çalýþtýrýlabilir programlar içeren dizinlerin listesi
LOGNAME	  Geçerli kullanýcýnýn kullanýcý ismi (tekrar)

$ export foo=bar

Ayný anda birden fazla deðiþkenler için ayný çalýþýr:

$ export foo baz
$ export foo=bar baz=quux

Export komutuyla tüm ortam deðiþkenlerini görüntüleyebilirsiniz (hiçbir parametre almadan). Ayrýca env komutu da (hiçbir parametre almadan) mevcut ortamý görüntüler.
Tüm kabuk deðiþkenleri (ortam deðiþkenlerini de içererek) set komutu kullanýlarak görüntülenebilir. En yaygoýn deðiþkenler ve onlarýn anlamlarý tablo 9.1 de
gösterilmiþtir.
	*Ayný zamanda set komutu farklý ve harika birçok þey yapar. Kabuk programlamayý kapsayan Advanced Linux Linup Ön Eðitim klavuzunda tekrar karþýlaþacaksýnýz.
	*Env aslýnda sadace ortam süreçlerini göstermek yerine iþlemek için tasarlanmýþtýr. Aþaðýdaki örneði inceleyin:

$ env foo=bar bash          Foo ile çocuk kabuðu baþlat
$ echo $foo
bar
$ exit                      Ana kabuða geri dön
$ echo $foo
                             Tanýmlý deðil
$ _

 	*En azýndan bash ile (ve iliþkiler) gerçekte geniþletilmiþ bir ortamla komutlarý çalýþtýrmak için env komutuna ihtiyaç duymazsýnýz.-Temelde ayný þeyi yapar.

$ foo=bar bash

Ancak env komutu da geçici ortam deðiþkenleri kaldýrmak için izin verir (nasýl?).
Bir deðiþken silme: Eðer yeterli kabuk deðiþkeni varsa unset komutunu kullanarak silebilirsiniz. Ayrýca bu çevreden onu siler. Eðer ortamdan bir deðiþkeni silip 
kabuk deðiþkeni olarak tutmak isterseniz "export -n" kullanýn:

$ export foo=bar 	foo ortam deðiþkeni
$ export -n foo 	foo kabuk deðiþkeni (sadece)
$ unset foo 		foo sonsuza dek gider ve kaybolur

9.3 Komut Tipleri-Yeniden Yükleme
 
Kabuk kontrol:Kabuk deðiþkenlerinin bir uygulamasý kabuðun kendisinin kontrolündedir. Ýþte baþka bir örnek: 4.bölümde de tartýþtýðýmýz üzere kabuk iç ve dýþ komutlarý
ayýrýr. Kabuk dýþ komutlarý PATH ortam deðiþkeninin deðerini oluþturan dizinlerde hangi çalýþtýrýlabilir programa karþýlýk geldiðini arar. Ýþte PATH için genel bir 
deðer:

$ echo $PATH
/home/joe/bin:/usr/local/bin:/usr/bin:/bin:/usr/games

Bireysel dizinler listedeki kolona göre ayrýlmýþ, bu nedenle listenin örneði olarak beþ dizin oluþur. Eðer bir komut giriþi yaparsanýz

$ ls

kabuk bunun iç komut olmadýðýný bilir (kendi iç komutlarýný bilir) ve bu nedenle PATH'i dizini en solundan araþtýrmaya baþlar. Özellikle, aþaðýdaki dosyalarýn mevcut
olup olmadýðýný kontrol eder:

/home/joe/bin/ls 		yok …
/usr/local/bin/ls 		hala þans yok …
/usr/bin/ls 			tekrar þans yok …
/bin/ls 			anlaþýldý!
 				dizin /usr/games kontrol edilemez.

Bu /bin/ls dosyasý adý üstünde ls komutu çalýþtýrmak için kullanýlýr. 
	*Tabiki bu arama oldukça karýþýk süreçlerdir. Bunun sebebi kabuðun gelecek için hazýrlýk yapmasýdýr: Eðer daha önce ls komutunun uygulasý olarak /bin/ls
	dosyasý tespit edilmiþ ise, þu an için bu yazýþmalar hatýrlanýr. "hashing" süreci çaðrýlýr ve bunun ls komut tipini uygulayarak meydana geldiðini
	görebilirsiniz.
 
$ type ls
ls is hashed (/bin/ls)

 	*Hash komutu hangi bash'de "hashing" olan emrediyor size söyler ve ne sýklýkla na zaman çaðrýldýðýný söyler. "hashing-r" ile kabuðun karma belleðini
	silebilirsiniz. Diðer bir kaç seçeneðe bash klavuzundan bakabilir ya da "help hash" kullanarak öðrenebilirsiniz.
	*Açýkça söylemek gerekirse PATH deðiþkenin bir ortam deðiþkeni olmasýna gerek yoktur- kabuk deðiþkeni mevcut kabuk için iyi durumda (bkz. alýþtýrma 9.5).
	Her halükarda bir ortam deðiþkeni olarak tanýmlamak için uygundur (genellikle de kabuklarý). Böylece kabuðun çocuk süreçlerinin istenilen deðeri kullanýlýr.
    Eðer kabuk kullanan belirli bir dýþ komut için programýn hangisi olduðunu tam olarak bilmek istiyorsanýz which komutunu kullanabilirsiniz:

$ which grep
/bin/grep

which, kabuðu ayný yöntemde kullanýr-ilk olarak PATH dizininde baþlar ve söz konusu dizinin istenilen komutu ile ayný ada sahip bir yürütülebilir dosya içerip
içermediðini denetler.
	*which kabuðun iç komutlarý hakkýnda hiçbir þey bilmiyor olmasýna raðmen “which test" komutu "/usr/bin/test" döndürür. Bu aslýnda iç komutlarýn önceliðe sahip
	olduðundan çalýþtýrýlabileceði anlamýna gelmez. Eðer emin olmak istiyorsanýz "type" kabuk komutunu kullanmanýz gerekir.
    whereis komutu çalýþtýrýlabilir programlarýn adlarýný döndürür; ama ayný zamanda belge (man pages), kaynak kodu ve söz konusu komut(lar) ile ilgili farklý
dosyalarý da döndürür. Örneðin:
 
$ whereis passwd
passwd: /usr/bin/passwd /etc/passwd /etc/passwd.org /usr/share/passwd >
</usr/share/man/man1/passwd.1.gz /usr/share/man/man1/passwd.1ssl.gz>
</usr/share/man/man5/passwd.5.gz

Bu örnekte whereis komutunu açýklayan (kabaca) doðrudan kodlanmýþ bir yöntem kullanýlmýþtýr (1).

ALIÞTIRMALAR:

9.3 [!2]  Çocuk süreçlerin çalýþmasý için Ortam ve kabuk deðiþkenlerine geçirerek aþaðýdaki komutlarýn sýrasýyla çalýþtýðýna dair kendinizi ikna edebilirsiniz.

$ foo=bar 		foo kabuk deðiþkeni
$ bash 		yeni kabuk (çocuk süreç)
$ echo $foo
			foo tanýmlý deðil
$ exit 		ana kabuða geri dön
$ export foo 		foo ortam deðiþkeni
$ bash 		yeni kabuk (çocuk süreç)
$ echo $foo
bar 			ortam deðiþkeni ile birlikte geçti
$ exit 		ana kabuða geri dön

9.4 [!2] Çocuk süreçte bir ortam deðiþkeni deðiþirse ne olur? Aþaðýdaki komutlarý sýrasýyla inceleyin:
 
$ foo=bar 		foo kabuk deðiþkeni
$ bash 		yeni kabuk (çocuk süreç)
$ echo $foo
bar 			ortam deðiþkeni ile birlikte geçti
$ foo=baz 		yeni deðer
$ exit 		ana kabuða geri dön
$ echo $foo 		ne alacaðýz??

9.5 [2] PATH bir ortam deðiþkeni yerine "sadece" basit bir kabuk deðiþkeni ise kabuðun komut satýrýnda aramayý çalýþtýrdýðýna da emin olun. Eðer PATH tamamen silinise
ne olur?

9.6 [!1] Aþaðýdaki komutlarý ele almak için hangi çalýþtýrýlabilir programlar kullanýlýr: fgrep, sort, mount, xter

9.7 [!1] Sistemdeki hangi dosyalar “crontab” komutu için belgeri içerir?

9.4 Elveriþli Bir Araç Olarak Kabuk

Kabuk birçok Linux kullanýcýlarý için en sýk kullanýlan araç olduðundan beri, geliþtiricileri tarafýndan kullanýmýný rahat hale getirmek için birçok sorunu çözmelmek 
üzere tartýþýldý. Daha kullanýþlý bazý önemsiz þeyler buradadýr:

Komut Editörü: Basit bir metin editöründeki gibi komut satýrlarýný düzenleyebilirsiniz. Bu sayede, enter tuþu kullanarak giriþ bitmeden önce keyfi karekterler
ekleyebilir veya silebilir ve giriþ satýrýnýn etrafýnda imleci hareket ettirebilirsiniz. Bu editörün davranýþlarý Linux üzerinde en popüler editörlerin "set-o vi" ve
"set-o emacs" komutlarýný kullanarak uyarlanabilir.
 
Durdurulan Komutlar: Linux komutlarý çevresinde çokça isim karýþtýrmak veya yanlýþ bir parametreye geçmek kolaydýr. Haliyle çalýþtýrýlma anýnda iptal komutu
olmalýdýr. Bu iþlem için sadece eþ zamanlý olarak Ctrl+c tuþuna basýlmalýdýr.

Tarihçe: Kabuk "tarih" in bir parçasý olarak þimdiye kadarki komutlarý hatýrlar. ^ ve v imleç tuþlarýný kullanarak bu komutlarýn listesinde hareket edebilirsiniz.
Yukarýda açýklandýðý gibi önceki komutu bulursanýz <-(enter) kullanarak tekrar çalýþtýrabilir veya düzenleyip kullanabilirsiniz. Ctrl + r komutunu kullanarak
"adým adým" listeyi arayabilirsiniz - sadece karakter dizisi yazdýðýnýzda ve kabuk bu diziyi içeren en son çalýþtýrýlan komutu gösterir. Uzun dizilerde arama daha
hassas.
	*Sistem oturumunuzu kapattýðýnýzda, kabuk gizli dosya ~/.Bash_history içinde geçmiþini depolar ve daha sonra giriþ yaptýktan sonra tekrar kullanýlabilir
	hale getirir. (Söz konusu isim HISTFILE deðiþkenini ayarlayarak farklý bir dosya adý kullanabilir.)
	* “plain” dosyasýnda depolanan geçmiþin saklanýr olduðunun bir sonucu olarak bu dosya metin editörü kullanýlarak düzenlenebilir (bölüm 3 ne söyler). Öyleki
	komut satýrýna yanlýþlýkla þifrenizi girdiniz, el ile tarihi kaldýrabilirsiniz - özellikle, sistem baþýboþsa ev dizinlerinden herhangi birini herkes görebilir.

Komut ve dosya adlarý tamamlanýyor
Otamatik Tamamlama: Otomatik olarak komut ve dosya adlarýný tamamlamak Bash kabuðunun muazzam bir yeteneðidir. Eðer tab tuþuna bastýðýnýzda kabuk benzersiz bir
tespit ile eksik bir girdi var ise devamýný tamamlar. Bir komutun ilk sözcüðü için, bash geçerli veya belirtilen dizindeki tüm dosyalarýn komut satýrý geri kalaný
içinde tüm çalýþtýrýlabilir programlarý düþünmektedir. Çeþitli komutlar veya dosyalarýn adlarý ayný baþlýyorsa, kabuk adýný mümkün olduðu kadar tamamlar
sonrasýnda komut veya dosya adý hala eksik olabilir. Ýkinci bir tab tuþuna basýldýðýnda kalan olasýlýklarý listeler.
	*Belirli programlara kabuðun tamamlama mekanizmasýný uygulamak mümkündür.Örneðin; bir FTP istemcisi, komut satýrýnda dosya adlarý yerine yakýn zamanda ziyaret
	ettiði FTP sunucularýnýn adlarýný sunabilir. Ayrýntýlar için bash belgelerine bakýn.
Tablo 9.2 de bash içindeki en önemli tuþlar hakkýnda bir göz gezdirilmiþtir.

Bir Satýr Üzerinde Çoklu komutlar: Ayný giriþ hattý üzerinde çeþitli komutlar girmek için mükemmel ücretsizdir. Sadece bir noktalý virgül kullanarak onlarý ayýrmak
gerekir:

$ echo Today is; date
Today is
Fri 5 Dec 12:12:47 CET 2008

Bu örnekte birinci komut çalýþtýrýlmýþ olduðunda, ikinci komut yürütülür.

Tablo 9.2: bash içindeki tuþlar
 
Tuþlar			Ýþlevleri

^ veya v		En son komutlar arasýnda gezinir
Ctrl+r			Komut geçmiþini arar
<- ->			Geçerli komut satýrý içindeki Ýmleci hareket ettirir
home Ctrl+a		Komut satýrýnýn baþýna gider
end Ctrl+e		Komut satýrý sonuna atlar
<- Del			Sýrasýyla, imlecin altýndaki/önündeki karakteri siler
Ctrl+t			Ýmlecin Önündeki ve altýndaki iki karakterin yerlerini deðiþtirir
Ctrl+l			Ekraný temizler
Ctrl+c			Komuta ara verir
Ctrl+d			Son giriþ (giriþ kabuklarý için:kapalý oturum)

Deðeri döndürür
Koþullu Yürütme: Bazen ilk komutun doðru çalýþýp çalýþmadýðýna baðlý olarak ikinci komutun çalýþtýrýlmasý kullanýþlýdýr. Her Unix süreçleri doðru çalýþan veya ne tür
hatalarýn meydana geldiðini belirten geri dönüþ deðeri dödürür. Önceki durumda, dönüþ deðeri 0; ikincisi de, 0 dan farklýdýr. $? deðiþkeniyle kabuðun çocuk sürecinin
geri dönüþ deðeri bulanabilir.

bash 			çocuk süreç baþlatýldý …
$ exit 33 		… ve hemen tekrar çýkldý
exit
$ echo $?
33 			yukarýdaki çýkýþ deðeri
$ _

Ama bunun sonrakiler üzerinde etkisi yoktur.

      Ýki komut arasýnda, "ayýrýcý" olarak && kullanýlýr (aksi halde noktalý virgül nerde ise), ilk komuttan baþarýlý bir þekilde çýkýldýðý zaman, ikinci komut
yalnýz yürütülür. Bunu görebilmek için kabuðun -c seçeneðini kullanabilirsiniz, bununla birlikte komut satýrý üzerinden çocuk kabuða bir komut iletilir (Etkileyici,
deðil mi?):

$ bash -c "exit 0" && echo "Successful"
Successful
$ bash -c "exit 33" && echo "Successful"
 					-33 hiç baþarýlý deðil

Aksine "ayýrýcý" olarak || kullanýmýnda ilk komut baþarýlý bitmediði taktirde ikinci komut yalnýz yürütülür. 
 
$ bash -c "exit 0" || echo "Unsuccessful"
$ bash -c "exit 33" || echo "Unsuccessful"
Unsuccessful

ALIÞTIRMALAR:

9.8 [3] “echo "Hello!"” komutunda ne yanlýþ? (Ýpucu: Form komutlarý "! -2" Ya da "! Ls" ile tecrübe edin.)

9.5 Dosyadan Komutlar

Bir dosya içinde kabuk komutlarý depolamayabilir ve bunu en bloc ile yürütebilirsiniz. (Elveriþli bir dosya oluþturma bölüm 3'de öðrenilecektir.) Parametre
olarak verilen dosya adýný sadece kabuðun çaýrmasý gerekir.

$ bash my-commands

Bunun gibi bir dosya kabuk betiði çaðýrýr ve çok kýsa özetleyebiliriz ki kabuk burada çok geniþ programlama özelliklerne sahiptir. (Advanced Linux Linup Ön
Eðitim klavuzunda detaylý olarak kabuk programlama açýklanýyor.)
	*Büyülü sözler ekleyerek dosyayý "çalýþtýrýlabilir" yaparak

		#!/bin/bash

	bash komutunun baþa eklenmek zorunda kalma durumunu engelleyebilirsiniz.
		
		$ chmod +x my-commands

	(Bölüm 14 de chmod ve eriþim haklarýyla ilgili daha fazla bilgi bulabilirsiniz.) Bundan sonra
		
		$ ./my-commands
	
	komutu yeterli olacaktýr.

     Eðer yukarýdaki gibi bir kabuk betiði çaðýrýlýrsa bash komutunu baþa ekleyerek veya dosyayý çalýþtýrarak geçerli kabuðun çocuk süreci bir alt kabukta çalýþtýrýlýr.
Bu da demektir ki, e. g., kabuk ya da ortam deðiþkenlerindeki deðiþikliklerin geçerli kabukta etkisi yoktur. Örneðin; dosyanýn atama satýrý içerdiðini varsayalým

foo=bar

Aþaðýdaki komut dizisi dikkate alýn:
 
$ foo=quux
$ bash assignment 		foo=bar içerir
$ echo $foo
quux 				Deðiþiklik yok; atama sadece altkabukda oldu

Bu genellikle bir özellik olarak kabul edilir, ama her zaman için (þimdi ve sonrasýnda) dosya komutlarýnýn mevcut kabuðu etkileyecek olmasý oldukça gereklidir. Bu da
çalýþýr: Eðer o anki kabukta bunlar doðrudan yazýlýrsa tam olarak kaynak komut dosyasý satýrlarýný okur -tüm deðiþkenlerdeki deðiþiklikleri- dolayýsýyla geçerli
kabuk da etkili olur:

$ foo=quux
$ source assignment 		foo=bar içerir
$ echo $foo
bar 				Deðiþken deðiþti!

Lafý gelmiþken kaynak komutu için farklý bir isim ".". (doðru okunmalý-nokta) Bu sebeple
 
$ source assignment

eþdeðerdir.

$ . assignment

 	*Dýþ komutlar için program dosyalarý gibi dosyalarýn okumasý kaynak veya . kullanarak PATH deðiþkeni tarafýndan verilen dizinleri aramasýyla olur.

9.6 Bir Programlama Dili Olarak Kabuk

Bir dosyadan kabuk komutlarý çalýþtýrmak için mümkün olduðunca iyi bir þey olduðuna emin olmak gerekir. Bununla birlikte her zaman ayný þeyleri yapmak zorunda olmadan
kabuk komutlarný daha iyi yapýlandýrmak mümkündür. Örneðin; komut satýrý parametreleri elde edilebilir. Avantajlarý açýktýr: Sýk kullanýlan prosedürleri, sürekli
yazmak sýkýcý olacaðýndan kaydedebilirsiniz ve nadiren kullanýlan süreçleri bu kaydýn dýþýnda býrakýn çünk bu sayede hatalarý hatalarý önemli ölçüde önleyebilirsiniz.
Kabuðun als programlama dilini açýklamak için burada yeterli bir alana sahip deðiliz; ama bir kaç örnek bunun için yeterli olacaktýr.

Tek parametre
Komut satýrý parametreleri: Bir kabuk betiðine komut satýrý parametrelerini ilettiðinizde, kabuk $1, $2 gibi deðiþkenleri kullanabilir hale gelir.Aþaðýdaki örneði
inceleyin:

$ cat hello
#!/bin/bash
echo Hello $1, are you free $2?
$ ./hello Joe today
Hello Joe, are you free today?
$ ./hello Sue tomorrow
Hello Sue, are you free tomorrow?

Tüm paremetreler
$ * bir kerede tüm parametreleri içerir ve $ # parametrelerin sayýsýdýr:

$ cat parameter
#!/bin/bash
echo $# parameters: $*
$ ./parameter
0 parameters:
$ ./parameter dog
1 parameters: dog
$ ./parameter dog cat mouse tree
4 parameters: dog cat mouse tree

Döngüler: For komutu kelimelerin bir listesi üzerinden yineleme ile döngü oluþturmayý saðlar(boþluklarla ayrýlmýþ).

$ for i in 1 2 3
> do
> echo And $i!
> done
And 1!
And 2!
And 3!

Burada, i deðiþkeniyle sýralý listelenmiþ varsayýlan deðerler, komutlar arasýndan do komutu ile yürütülür.
    Eðer kelimeler bir deðiþken alýnýrsa bu daha eðlenceli hale gelir:

$ list='4 5 6'
$ for i in $list
> do
> echo And $i!
> done
And 4!
And 5!
And 6!

Parametreler üzerinde döngü
Eðer "in ..." yazmazsanýz, döngü komut satýrý parametreleri üzerinde dolaþýr:

$ cat sort-wc
#!/bin/bash
# Sort files according to their line count
for f
do
echo `wc -l <"$f"` lines in $f
done | sort -n
$ ./sort-wc /etc/passwd /etc/fstab /etc/motd

("Wc-l" komutunu komut satýrýna geçirilen standart giriþ veya dosya(lar) satýrlarý saymaktadýr.) Ýþ hattý kullanarak sýralamak için döngüyü standart çýktýya 
yönlendirme unutulmamalýdýr!

Alternatifler: Sadece belirli koþullar altýnda belirli komutlarý çalýþtýrmak için daha önce de anlatýlan | | ve && operatörlerini kullanabilirsiniz.

#!/bin/bash
# grepcp REGEX
rm -rf backup; mkdir backup
for f in *.txt
do
grep $1 "$f" && cp "$f" backup
done

Betik, örneðin; parametre olarak iletilen düzenli ifade ile eþleþen en az bir satýr içerirse (for döngüsü saðlar) ve ismi .txt ile sonlanýyorsa sadece backup
dizine bir dosya kopyalar.
     test
     Alternatifler için yararlý bir araç olarak çeþitli þartlarda kontrol saðlayan test komutu vardýr. Koþul gerçekleþirse çýkýþ kodu 0 döndürür (baþarýlý),
gerçekleþmemesi durumunda sýfýrdan farklý bir çýktý verir (baþarýsýz). Örneði inceleyin:

#!/bin/bash
# filetest NAME1 NAME2 ...
for name
do
test -d "$name" && echo $name: directory
test -f "$name" && echo $name: file
test -L "$name" && echo $name: symbolic link
done

Bu betik dizin yerine kullanýlan her bir dosya veya sembolik dizin için parametrelerin ve çýkýþlarý olarak iletilen dosya isimlerinin sayýsýna bakar.

!Test komutu hem bin/test teki gibi serbest çalýþan bir program olarak hem de bash ve diðer komutlardaki gibi dahili olarak mevcuttur. Çok daha garip testler söz 
konusu olduðunda bu deðiþmeler ince farklýlýklar gösterebilir. Þüpheniz varsa, belgeleri okuyun.

     Eðer bir koþulla, birden fazla komutu baðýmlý kýlacak bir komut varsa kullanabilirsiniz (uygun ve okunabilir bir þekilde). "[...]" yerine "test ..." yazýlabilir:

#!/bin/bash
# filetest2 NAME1 NAME2 ...
for name
do
if [ -L "$name" ]
then
echo $name: symbolic link
elif [ -d "$name" ]
echo $name: directory
elif [ -f "$name" ]
echo $name: file
else
echo $name: no idea
fi
done

Eðer komut sinyali "baþarýlý" ise (çýkýþ kodu 0) komutlar yürütülür, sonrasýnda gelen elif, else veya fi komutlarý sona erer. Öte yandan sinyal "baþarýsýz" ise sonraki
elif komutu deðerlendirilmeye alýnacak ve çýkýþ kodu olarak kabul edilecektir. Eþleþen fi komutuna ulaþýlana kadar kabuk modele devam eder. If veya elseif 
komutlarýndan hiç biri "baþarý" ile sonuçlanmadý ise sonrasýnda else komutu yürütülür. Bunlar gerekli deðilse elif ve baþka dallanmalar ihmal edilebilir.

Daha fazla döngü: Baþlangýçta döngü için sabit bir dönme sayýsý belirlenir (Listedeki sözcük sayýsý). Ancak, sýk sýk bir döngü ne sýklýkta çalýþtýrýlmalýdýr; Bu gibi 
net olmayan durumlar ile en baþta ilgilenmek gerekir. Komut çalýþýrken (If gibi) "baþarýlý" yada "baþarýsýz" olduðu belirlenebilir. Bunu halledebilmek için kabuk while
komutunu sunar. Sonuç baþarýlý ise "baðlý" komutlar çalýþtýrýlýr, baþarýsýz ise döngüden sonraki komutlar çalýþtýrýlacaktýr.
     Aþaðýdaki betik gibi bir dosyayý okur

Aunt Maggie:maggie@example.net:the delightful tea cosy
Uncle Bob:bob@example.com:the great football

     (Adýný Komut satýrýna veren) ve her satýrda bir teþekkürler e-posta sý oluþturur (Linux günlük yaþamda çok yararlýdýr):

#!/bin/bash
# birthday FILE
IFS=:
while read name email present
do
(echo $name
echo ""
echo "Thank you very much for $present!"
echo "I enjoyed it very much."
echo ""
echo "Best wishes"
echo "Tim") | mail -s "Many thanks!" $email
done <$1

okuma
read komutu giriþ dosyasýndaki satýrlarý okur ve her satýrý üç kolon olarak bölümlendirir. Bu kolonlar isim email ve döngü içinde bulunan mevcut deðiþkenlerdir.
Mantýða aykýrý olarak döngüye yeniden yönlendirilen giriþ sonda bulunabilir. 
	!Zararsýz e-posta adresleri ile bu betiði test edin, sizin iliþkilerinizi karýþýk hale getirir!

ALIÞTIRMALAR:

9.9 [1] Arasýndaki fark (olduðu kadar döngü çalýþtýrma söz konusu olduðunda) nedir?
		for f; do …; done
	ve
		for f in $*; do …; done
	(Eðer gerekirse deneyin)

9.10 [2] Sort-wc betiðini neden biz kullanýyoruz
		wc -l <$f
	yerine
		wc -l $f

9.11 [2] grepcp deðiþtirilebilir. Bu þekilde dikkat edilmesi gereken dosyalarýn listesi de komut satýrýndan alýnýr. (Ýpucu: Shift kabuk komutu $ dan ilk komut satýrý 
parametresini siler ve oluþacak açýðý kapatmak için diðerlerini yukarý çeker. Kaydýrmadan sonra, önceki $2 $1 olur, $3 de $ 2 olur ve böyle devam eder.)

9.12 [2] Neden filetest komutunun çýktýsý yok
	$ ./filetest foo
		foo: file
		foo: symbolic link
	
	sembolik linkler için (sembolik bað «yerine sadece» foo)?


Bu Bölümdeki Komutlar

.		Komut satýrýna giriþ yapýlýrsa kabuk komutlarýný içeren dosyalarý okur 	 				bash(1) 127
date		Tarih ve saati görüntüler						 				date(1) 120
env		Süreç ortamý Çýkýþlarýný veya ayarlanmýþ ortam programlarýný baþlatýr					env(1) 122
export		Tanýmlananlarý ve ortam deðiþkenlerini yönetir								bash(1) 121
hash		bash deki "'görülen"' komutlarý gösterir ve yönetir							bash(1) 123
set		Kabuk deðiþkenlerini ve seçeneklerini yönetir								bash(1) 122
sourse		Komut satýrýna giriþ yapýlýrsa kabuk komutlarýný içeren dosyalarý okur					bash(1) 127
test		Komut satýrýnda mantýksal ifadeleri deðerlendirir							test(1), bash(1) 129
unset		Kabuk veya ortam deðiþkenlerini siler									bash(1) 122
whereis		Çalýþtýrýlabilir programlarý, el ile oluþturulmuþ sayfalarý ve kaynak kodu verilen programlarý arar	whereis(1) 123
which		PATH boyunca programlarý arar										which(1) 123

ÖZET:
*sleep komutu argüman olarak belirtilen saniye sayýsý için bekler.
*Echo komutu argümanlarý çýktýlar.
*Tarih ve saat date komutu kullanýlarak tespit edilebilir.
*bash gibi çeþitli özellikler komutu ve dosya adýný tamamlama, komut satýrý düzenlemesi, takma adlarý ve deðiþkenler gibi interaktif kullanýmý destekler.

